---
title: "LLMをまたいで同じ知識を使うためのNotionKGS CLI設計"
emoji: "🕸️"
type: "tech"
topics: ["Notion", "KnowledgeGraph", "CLI", "Bun", "Productivity"]
published: true
---

## Introduction
以下、個人で使ってるLLM x Notionを用いた、複数LLM間での共有知の構築について、Codex に記事を書かせてみました。2025年は、やれ「Claudeがいい」「Codexがきてる!」「Geminiいいぞ」とリリースのたびに世間が賑わい、知識やプロンプトを都度都度設定するのも面倒だったんですよね... それを「NotionにまとめたからMCP使って見に行って」という運用に落ち着かせた話です。きっとこの記事をAIに読ませれば、あなたの環境でも同じことができる... はず！ぜひやってみてください！それでは、以下、Codexくんの記事になります！

## TL;DR
複数LLMに同じ知識グラフを配給するために、Notionをソース、ローカルJSONを共有キャッシュにした二層構成を採った。init/query/save の実装をソースとログで示し、MemOS/HRMで最適化して応答の揺らぎを抑えている。最後に、ハブ設計のチェックリストと他方式（Notion単体・Obsidian・Algolia・LLM直検索）とのトレードオフをまとめた。

## 背景とストーリー

個人の知識を「書き散らす→探せない」を何度も繰り返した末に、NotionデータベースとローカルCLIを双方向同期する **NotionKGS (Notion Knowledge Graph System) CLI** を自作した。この記事ではリポジトリ内の設定ファイルや運用ルールを振り返りつつ、外部公開しても差し支えない範囲で仕組みをまとめる。

### 課題と要件
LLMごとにプロンプトや知識が散らばって回答が揺れる状態を止めたい。同じ出典と観察をどのLLMにも参照させ、日本語と英語が混在するメモでも一貫して検索できるようにする。また、APIキーやDB ID などの秘匿情報をローカルや環境変数で守り、公開時に確実にマスクできる構造が求められた。

### なぜNotionKGS CLIにしたか
Notionを一次ソースに、ローカルJSONをLLM共有キャッシュにする二層構成がシンプルで自動化もしやすいと判断した。CLIならプロンプト注入やファイル取り込みをスクリプト化でき、LLMごとに同じKGを配布しやすい。MemOSとHRMで検索品質を底上げし、出典付き観察を返すことで応答の揺らぎを抑える狙いもあった。

### 失敗と学びのハイライト
最初は「Notionだけで十分」と考えていたが、LLMごとにプロンプトや知識がバラけて再利用性が落ち、共通KGを中心に据える設計へ転換した。MarkdownをGitに集める案はタグ管理と多言語対応で破綻し、観察を多言語配列で持つことで解決した。LLMに直接聞く運用では出典が曖昧になり誤引用が発生したため、グラフ構造と観察文を必ず返す方針に切り替えた。

## 全体アーキテクチャ（LLM共有視点）

```
Notion DB (Entities / Relations)
        ↕ 双方向同期
Local Storage (data/knowledge-graph.json)
        ↕ CLI (nkgs …)
        ↕ MemOS/HRM/RRS モジュール
```

共有ハブとして、Notionを真実のソース、ローカルJSONを複数LLMへの配布キャッシュとして利用する。タイムスタンプで衝突を検出し、`nkgs status` で可視化する仕組みを持つ。モジュールは冗長・復旧を担う NKGS-RRS、キャッシュとメモリ管理を行う MemOS（LRU やプリロードを備える）、重要度をスコアリングする HRM で構成される。

## データモデルの実物例

`data/knowledge-graph.json` にはエンティティとリレーションがJSONで保持されている。たとえば「NotionKGS自動ファイル読み込み」は `/Users/*****/_dev-local/__prompt/` のMarkdownをinit時に自動インポートし、ローカルとNotionを統合する観察を持つ。「タスク収集作業フロー」は Notion Tasks DB や Jira、Google Workspace から Today/進行中を集約する手順を DB ID や JQL 付きで記録している。「Claude料金問い合わせ」は `bunx ccusage` を叩く標準応答を、「今日のタスク教えて」は複数ソースをまとめて優先順位付きで返すフォーマットを定義する。リレーションとしては `NotionKGS自動ファイル読み込み → プロンプトディレクトリ (related_to)` や `Claude料金問い合わせ → ccusageコマンド (related_to)`、`Claude → Anthropic (works_for)` が登録されており、`query` がこれらを辿って関連ノートを返す。

## コマンド実装の中身（抜粋）

### init

`src/commands/init.js` は Notion から entities/relations を取得し `KnowledgeGraph` に上書きする。特殊エンティティ `NotionKGS自動ファイル読み込み` を検出すると、観察文に書かれたパス（例 `/Users/skmt3p/_dev-local/__prompt/`）の `.md` を走査して `Document` エンティティにし、`loads_from` リレーションを張る。処理中は `ora` のスピナーで進捗を出し、完了後に件数をログに示す。

```javascript
// src/commands/init.js 抜粋
spinner.text = 'Fetching entities...';
const entities = await notionClient.getEntities();
spinner.text = 'Fetching relations...';
const relations = await notionClient.getRelations();
await kg.clear();
kg.addEntities(entities);
kg.addRelations(relations);
await processAutoFileLoading(entities, kg, spinner); // /__prompt/*.md を吸い上げる
await kg.save();
```

`processAutoFileLoading` で観察文に書かれたパスを正規表現で抽出し、`.md` 群を自動インポートする。

```javascript
const pathMatch = observationText.match(/(?:対象パス|path):\s*([^\s\n]+)/i);
const mdFiles = files.filter(file => file.endsWith('.md'));
kg.addEntity(fileEntity.name, 'Document', fileEntity.observations.ja);
kg.addRelation({ from: autoLoadEntity.name, to: 'プロンプトディレクトリ', relationType: 'loads_from' });
```

### query

`src/commands/query.js` は `nkgs query <search>` を受け取り、`--optimize` が付いていれば `OptimizedKnowledgeGraph` を経由して `optimizationManager.optimizeQuery()` を呼び、MemOS/HRM のキャッシュと推論を使う。`--stats` を付けると走査エンティティ数やキャッシュヒット数、推奨事項が表示される。デフォルトは `KnowledgeGraph.search` が多言語オート判定で検索し、日本語なら `ja` 観察を優先する。結果はエンティティ名・タイプ・最大3件の観察とリレーション一覧を整形して返す。

```javascript
// src/commands/query.js 抜粋
const kg = options.optimize ? new OptimizedKnowledgeGraph() : new KnowledgeGraph();
await kg.load();
let results;
if (options.optimize && kg.optimizationManager) {
  results = await kg.optimizationManager.optimizeQuery(kg, search, {
    language,
    maxResults: options.limit || 50,
    includeStats: options.stats,
  });
} else {
  results = await kg.search(search, language);
}
```

`KnowledgeGraph.search` は多言語を判定し、名前・別名・観察を走査して返す。

```javascript
const matchingEntities = this.data.entities.filter(entity => {
  const nameMatch = entity.name.toLowerCase().includes(lowerQuery);
  const obsMatch = this.searchInObservations(entity.observations, lowerQuery);
  return nameMatch || obsMatch;
});
return { entities: this.formatEntitiesForDisplay(matchingEntities, language), relations: matchingRelations };
```

### 最適化/HRM/キャッシュ系

`OptimizedKnowledgeGraph` は MemOS/HRM をバックグラウンド初期化し、重要度に応じてキャッシュ配置する。

```javascript
// src/knowledge-graph-optimized.js 抜粋
this.useOptimization = process.env.NKGS_USE_OPTIMIZATION === 'true';
this.optimizationMode = process.env.NKGS_OPTIMIZATION_MODE || 'passive';
this.memos = new MemOSMemoryManager(this.config || {});
this.hrm = new HRMReasoningEngine(this.config || {});
this.optimizationManager = new OptimizationManager(this.optimizationMode);

async _performInitialOptimization() {
  for (const entity of this.data.entities) {
    const importance = await this._quickImportanceAnalysis(entity);
    const priority = importance >= 0.8 ? 'high' : importance >= 0.6 ? 'normal' : 'low';
    await this.memos.storeEntity(entity.name, entity, priority);
  }
}
```

`nkgs query --optimize` で `OptimizationManager.optimizeQuery()` が呼ばれ、キャッシュ命中数や推奨が表示される。

### add-entity / add-obs / add-alias

- `add-entity` は Commander オプション `--type` `--observations` 付きで `KnowledgeGraph.addEntity` を呼び、ローカルのみ更新。  
- 多言語追加系は `multilingual.js` で `observations[lang].push(...)` を行い、別名も `aliases.en/ja/primary` に格納。`validate` でフォーマットチェック。  

### health / recovery / memory-* / reasoning-*

- `health` は RRS の状態確認、`recovery [working|emergency]` で復旧シナリオを実行。  
- `memory-*` は MemOS の初期化・統計・負荷テスト・クリーンアップ。  
- `reasoning-*` は HRM による重要度分析やグラフ最適化（推論キャッシュのクリアも含む）。

## インストールとCLI呼び出しの詳説

1. Bun と repo を準備  
   ```bash
   cd ~/.claude/plugins/notion-kgs-cli
   bun install
   ```
2. API設定  
   - `config.json` の `apiKey` / `databases` を自分の値に差し替え、もしくは `.env` で上書き。  
3. 実行方法  
   - 簡易: `./run.sh init` / `./run.sh query "Claude"`  
   - グローバル: `./install.sh` 実行後はどこでも `nkgs ...` が使える。

## 実行ログイメージ

`nkgs init` 実行時（例）:
```
Initializing knowledge graph from Notion...
Fetching entities...
Fetching relations...
Processing auto-loading instructions...
Loaded prompt-001.md
Loaded prompt-002.md
✅ Initialized with 13 entities and 19 relations   # 現在の同梱データ基準
📊 Knowledge Graph Summary:
  Entities: 13
  Relations: 19
  Entity Types: Concept, Document, Organization, Person, Location
```

`nkgs query "Claude" --optimize --stats` の出力例:
```
🚀 Using optimized query (passive mode)...
🔍 Search results for: "Claude"
Language: 日本語

📊 Entities (5):
  Claude (Person)
    - AI assistant created by Anthropic
    - Helpful for various tasks
    - Can work with knowledge graphs
    ... and 2 more

🔗 Relations (7):
  Claude --[works_for]--> Anthropic
  Claude料金問い合わせ --[related_to]--> Claude
  Claude CodeとCodex併用ノート --[related_to]--> Claude

⚡ Performance: 12ms, 35 entities scanned, 4 cache hits
💡 Recommendations:
  - Enable aggressive cache for frequent queries
```

`nkgs add-entity "AI Ops Memo" --type "Document" --observations "LLM運用メモ"` 後に `nkgs save` を叩くと、ローカルJSONが更新され、`save` が Notion API に PUT する（CLIは config.json の DB ID を参照）。

`nkgs status` 実行時の実装は `status.js` で `getStats`/`getSyncInfo` を呼び、エンティティ数とローカル未同期の有無を表示する。未同期なら「Run \"nkgs save\"」と警告が出る。

```javascript
// src/commands/save.js 抜粋
const entities = kg.getEntities();
const relations = kg.getRelations();
await notionClient.syncEntities(entities);
await notionClient.syncRelations(relations);
await kg.updateSyncTimestamp();
```

```javascript
// src/commands/status.js 抜粋
const stats = await kg.getStats();
const syncInfo = await kg.getSyncInfo();
console.log(`Entities: ${stats.entities}`);
console.log(`Relations: ${stats.relations}`);
if (syncInfo.hasLocalChanges) {
  console.log('⚠️  You have unsaved local changes. Run \"nkgs save\"');
}
```

## リポジトリ構成の要点

コードは `/Users/*****/.claude/plugins/notion-kgs-cli/` にあり、中心となるのは Commander.js でサブコマンドを束ねる `src/index.js`、オフラインキャッシュ本体の `data/knowledge-graph.json`、高速検索用の `src/knowledge-graph-optimized.js`、APIキーとDB ID を持つ `config.json`（公開時は必ずマスク/環境変数化）、そして Codex/Claude向けの実行メモ `CLAUDE_CODE.md` / `CLAUDE_DESKTOP.md` だ。

### ディレクトリツリー（主要部）

```
notion-kgs-cli/
├── config.json                # Notion APIキー/DB ID
├── data/                      # ローカルキャッシュ
│   ├── knowledge-graph.json   # 本体
│   ├── knowledge-graph-backup.json
│   └── reasoning/             # HRM/MemOSキャッシュ
├── run.sh                     # 簡易起動ヘルパー
├── install.sh                 # nkgs をグローバルインストール
├── src/
│   ├── index.js               # CLIエントリ
│   ├── knowledge-graph.js     # 標準KG
│   ├── knowledge-graph-optimized.js # MemOS/HRM統合版
│   ├── notion-client.js       # Notion APIラッパー
│   ├── commands/              # 各サブコマンド実装
│   └── core/                  # MemOS/HRM/RRS/opt-manager
└── README.md / INTRODUCTION.md
```

### 処理フロー（テキスト版）

1. `nkgs init`  
   - Notionからentities/relations取得 → ローカルKGへ上書き  
   - 観察文に指定されたディレクトリのMarkdownを自動取込み  
   - KG保存＆統計表示  
2. `nkgs query <term> [--optimize --stats]`  
   - ローカルKG（必要なら最適化版）読み込み  
   - 多言語判定 → 検索 → 結果とリレーションを整形出力  
   - `--stats` で走査件数・キャッシュヒット・推奨を表示  
3. `nkgs add-entity / add-obs / add-alias`  
   - ローカルKGを更新（まだNotionには送らない）  
4. `nkgs save`  
   - ローカルKGをNotion APIに同期（entities/relationsを順にPUT）  
   - `updateSyncTimestamp` で同期時刻を記録  
5. `nkgs status`  
   - `getStats`/`getSyncInfo` を表示し、未同期なら save を促す

> シンプルなフローチャート
>
> Notion DB ⇄ NotionClient ⇄ KnowledgeGraph(JSON) ⇄ nkgs CLI  
>                           ↑ (init時) auto-load markdown  
>                           ↓ (save時) syncEntities / syncRelations  
> query → search/optimize → results + relations + stats (optional)

### システム構成図（Mermaid）

```mermaid
flowchart LR
  subgraph Notion["Notion Databases"]
    E[Entities DB]
    R[Relations DB]
  end

  subgraph CLI["nkgs CLI (Commander)"]
    INIT[init]
    QUERY[query / show / translate]
    ADD[add-entity / add-obs / add-alias]
    SAVE[save]
    STATUS[status]
  end

  subgraph Core["Core (src/)"]
    KG[KnowledgeGraph JSON]
    OKG[Optimized KG\n(MemOS + HRM)]
    MEMOS[MemOS Memory]
    HRM[HRM Reasoning]
  end

  subgraph FS["Local FS"]
    MD[/__prompt/*.md/]
    DATA[data/knowledge-graph.json]
    CACHE[data/reasoning/*]
  end

  Notion <--> |syncEntities/syncRelations| INIT
  Notion <--> |syncEntities/syncRelations| SAVE
  INIT -->|build + auto-load| KG
  INIT -->|auto-load| MD
  KG <-->|optimize| OKG
  OKG --> MEMOS
  OKG --> HRM
  QUERY --> KG
  QUERY --> OKG
  ADD --> KG
  SAVE --> Notion
  STATUS --> KG
  KG --> DATA
  OKG --> CACHE
```

### 設定まわり

`config.json` には API キーと DB ID (`entities`, `relations`) を記載する。公開記事や共有時は以下のようにプレースホルダーへ置換して扱う。

```jsonc
{
  "notion": {
    "apiKey": "YOUR_NOTION_API_KEY",
    "databases": {
      "entities": "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx",
      "relations": "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
    }
  },
  "local": { "dataPath": "./data", "cacheEnabled": true, "autoSyncInterval": 300 },
  "sync": { "conflictResolution": "manual", "backupBeforeSync": true },
  "optimization": { "enabled": false, "mode": "passive" }
}
```

`.env` に環境変数で渡す運用も可能（`CLAUDE_CODE.md` 参照）。APIキーは絶対にコミットしない。

## コマンドと運用フロー

セットアップ（Bun前提）:

```bash
cd ~/.claude/plugins/notion-kgs-cli
bun install
```

日常オペレーション:

```bash
# 初期化: Notion → ローカル
nkgs init

# 追加/更新
nkgs add-entity "Machine Learning" --type "Technology" \
  --observations "Pattern recognition" "AI subset"

# 検索（全文/関連/多言語対応）
nkgs query "Claude"

# 状態確認
nkgs status

# ローカル → Notion へ反映
nkgs save
```

メンテナンスでは `nkgs health` で健全性を確認し、`nkgs recovery` で自動復旧フローを走らせる。`nkgs memory-cleanup` はキャッシュ最適化、`nkgs analyze-importance <entity>` は HRM で重要度を再計算する。

## LLM共有ハブを支える仕掛け

- `backupBeforeSync: true` で同期前スナップショットを保持（LLMが参照するKGを壊さない）  
- `autoSyncInterval` でNotion⇄ローカルのズレを自動抑制  
- 競合はタイムスタンプで検出し `status` で明示、LLMには常に一貫したKGを渡す

## 他の選択肢と比較してみる

Notion標準検索はオンライン依存で遅延が大きいが権限共有は強く、検索面はローカル化で補完した。Obsidian + Dataview はローカル最速だがチーム共有と双方向同期が弱く、Notion DB との橋渡し役としてKGSを選んだ。Algolia/Meilisearch自前運用は高速だがインデックス構築とホスティングが重く、個人運用ではBun CLIで十分な速度を確保できると判断した。LLMベース検索だけに頼ると出典と構造が残りにくいため、グラフ構造と観察文を保持した上でLLMを活用する方針を取っている。

## これから作る人向けチェックリスト

まずオフライン要件を決め、JSONローカル化かローカルDBかを選ぶ。同時に同期先をNotion・Dropbox・Gitのいずれかに絞る。秘匿情報は config を env で上書きできるようにし、公開時に必ずマスクする運用を整える。自動取込みの入口をディレクトリ監視にするか手動コマンドにするかを決め、重要度（HRM相当）とキャッシュ層で検索品質を上げる方針を用意する。最後に、backupBeforeSync と status で復旧動線を可視化しておく。

## Notion実データの扱いガイドライン

APIキーやDB ID は記事掲載時に必ずマスクする（例: `20528ff7-298b-....` を `20528ff7-****` に置き換える）。観察に業務固有のタスクや DB ID、Jira cloudId が含まれる場合は、外部公開時に抽象化するか一部削除する。ローカルJSONをそのまま貼らず、出典が分かる要約や抜粋にとどめる。

## これからの改善アイデア（LLM視点）

LLMが参照する前に人間が整合性チェックできるグラフ可視化UIを追加したい。複数環境への一括配布のためにバッチインポート/エクスポートを用意し、`query`/`show` をHTTPで返す軽量APIラッパも検討する。さらに、クエリ頻度に応じてMemOSプロファイルを自動切り替え、LLMプロンプトのレイテンシを最適化する余地がある。

## Before / After（LLM運用の揺れを減らす観点）

導入前は LLM ごとにプロンプトと観察が散り、同じ質問でも回答が揺れ、モデルごとに質問を用意する運用コストも高かった。導入後は KG(JSON) を一元管理し `nkgs query` 経由で同じ観察と関係を返せるため、LLM間の回答揺らぎが減り、プロンプトを差し替えるだけで別LLMへ配布できるようになった。

## LLM共有ハブとしての効きどころ
共通KGを置けば、ClaudeでもCodexでも同じ観察と関係を参照できる。auto-loadで最新のプロンプトやメモをKGへ流し込めば、LLM側はKG経由で参照するだけになり運用が簡素化する。競合やバックアップはNotion側に残るため、キャッシュ層はLLMレスポンス最適化に専念できる。

## 読後に持ち帰れるもの
複数LLMで同じ知識を共有するためのKGハブ構成と実装ロードマップ、多言語観察や自動MD取込み、MemOS/HRM最適化のコード断片と設計意図、公開時に気をつける秘匿情報マスキングと抽象化の手順、そして「LLMごとに回答が揺れる」を抑えるための設計チェックリスト。このセットを持ち帰り、自分のLLM群に共通の知識ハブを用意してほしい。

## Zennリポジトリへの追加手順（メモ）

ZennのREADMEには公式ドキュメントへのリンクのみがあり、ローカルでは `articles/` 配下に Markdown を追加すればよい。CLIを使う場合は `npx zenn new:article` でslugを生成してから本記事のように編集する。公開時は `published: true` に切り替え、プライベート情報が入っていないか再確認すること。

## まとめ

NotionKGS CLIは「個人の知識を構造化して即座に引き出す」ことに全振りしたツールだ。オフラインで速く、Notionと安全に同期できることが強み。この記事が同じ課題を感じている人の参考になれば幸い。
